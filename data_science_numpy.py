# -*- coding: utf-8 -*-
"""Data Science: NumPy

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TzctT0JZbVv1dz7ae4oeu2B-c3U2OMqU

### NumPy: análise numérica eficiente com Python

### 1 - Conhecendo a biblioteca e nossos dados
"""

import numpy as np

url = 'https://raw.githubusercontent.com/alura-cursos/numpy/refs/heads/dados/apples_ts.csv'

dado = np.loadtxt(url,delimiter=',',usecols=np.arange(1,88,1))

7*12+3

np.arange(1,88,1)

"""As listas em Python são estruturas de dados básicas que podem conter elementos de diferentes tipos (inteiros, strings, outras listas, etc.). Já a Numpy (Numerical Python) é uma biblioteca do Python que fornece suporte a arrays multidimensionais, estruturas de dados mais avançadas e eficientes para cálculos numéricos.

Aqui está um exemplo de como transformar uma lista em um array Numpy:
"""

import numpy as np

# cria uma lista
lista = [1, 2, 3, 4, 5]

# transforma a lista em um array Numpy
array = np.array(lista)

print("Lista: ", lista)
print("Array: ", array)

"""Existem várias vantagens em usar arrays Numpy ao invés de listas regulares do Python e aqui estão algumas:

Eficiência de processamento
As operações matemáticas em arrays Numpy são muito mais rápidas do que em listas regulares, pois a NumPy foi otimizada para trabalhar com conjuntos de dados homogêneos e libera memória do computador rapidamente.

Facilidade de uso
As operações matemáticas em arrays Numpy são expressas de forma muito mais clara e concisa do que em listas regulares, tornando o código mais fácil de ler e manter.

Integração com outras bibliotecas
A Numpy é uma das bibliotecas mais utilizadas em ciência de dados e aprendizado de máquina. Muitas outras bibliotecas, como a Pandas e a Matplotlib, são projetadas para trabalhar diretamente com arrays Numpy.

Comparativo de performance: listas vs arrays

Focando na eficiência, podemos comparar o tempo levado para efetuar um cálculo utilizando listas e arrays.
"""

import numpy as np
import time

# cria uma lista com 1000000 elementos
lista = list(range(1000000))

# transforma a lista em um array Numpy
array = np.array(lista)

# começa a cronometrar o tempo para a operação com a lista
start_time = time.time()

# realiza a operação de elevar ao quadrado cada elemento da lista
lista_quadrado = [i**2 for i in lista]

# para o cronômetro
list_time = time.time() - start_time

# começa a cronometrar o tempo para a operação com o array
start_time = time.time()

# realiza a operação de elevar ao quadrado cada elemento do array
array_quadrado = array**2

# para o cronômetro
array_time = time.time() - start_time

print("Tempo da operação com a lista: ", list_time) #lista regular é mais lenta
print("Tempo da operação com o array: ", array_time) # array numpy é muito mais rápida

dado

dado.ndim # são ou temos dados com duas dimensões

dado.size # numero/quantidados de dados

dado.shape # quer dizer que temos 6 linhas e 87 colunas

dado.T # transposição array: transforma as linhas em colunas

dado_transposto = dado.T

"""### Exemplo:
Um colega pediu para você carregar uma base de dados e verificar o número de linhas e colunas do arquivo carregado. Ele estava com dúvidas se o número total de linhas havia sido carregado.

Como determinar as dimensões corretas de um array?

Para responder essa pergunta você precisará do dataset. Você pode usar a opção skiprows=1 para pular a primeira linha do arquivo.
"""

url = 'https://raw.githubusercontent.com/allanspadini/numpy/dados/bytebank.csv'
import numpy as np
dado1= np.loadtxt(url, delimiter=',',skiprows=1,dtype=float)
dado1.shape # O método .shape pode ser aplicado em um array para obter as suas dimensões.

url = 'https://raw.githubusercontent.com/allanspadini/numpy/dados/bytebank.csv'
import numpy as np
dado1= np.loadtxt(url, delimiter=',',skiprows=1,dtype=float)
np.shape(dado1)

"""### Teste Conhecimentos
Chegou a hora de você testar os conhecimentos desenvolvidos durante a aula. Para isso, vamos utilizar outro dataset em um desafio que será desenvolvido no decorrer do curso. Esse dataset é uma versão modificada do arquivo Oranges vs. Grapefruit presente no site do Kaggle. Portanto, utilizaremos o arquivo raw disponível no GitHub.

Nessa etapa, você deve efetuar a leitura dos dados. Para isso, importe a NumPy e use a função loadtxt. Use o link da url e o parâmetro usecols para pular a primeira coluna. É possível usar np.arange para criar a sequência de números que representam as colunas. Por fim, também é necessário incluir o parâmetro skiprows=1 para que a primeira linha de texto seja desconsiderada na leitura do arquivo.
"""

import numpy as np
url = 'https://raw.githubusercontent.com/allanspadini/numpy/dados/citrus.csv'
dado2 = np.loadtxt(url, delimiter=',',usecols=np.arange(1,6,1),skiprows=1)

dado2

dado2.T

"""### Resumo
Nessa aula, você aprendeu a:
Criar arrays com sequências numéricas.
Carregar arquivos.
Verificar as dimensões de um array.
Realizar a transposição de um array.

### 2 - Exploração dos dados
"""

datas = dado_transposto[:,0]

precos = dado_transposto[:,1:6]

import matplotlib.pyplot as plt # para gerar gráficos

datas = np.arange(1,88,1)

plt.plot(datas, precos[:,0])

Moscow = precos[:,0]
Kaliningrad = precos[:,1]
Petersburg = precos[:,2]
Krasnodar = precos[:,3]
Ekaterinburg = precos[:,4]

Moscow

Moscow.shape

Moscow_ano1 = Moscow[0:12]
Moscow_ano2 = Moscow[12:24]
Moscow_ano3 = Moscow[24:36]
Moscow_ano4 = Moscow[36:48]

plt.plot(np.arange(1,13,1), Moscow_ano1)
plt.plot(np.arange(1,13,1), Moscow_ano2)
plt.plot(np.arange(1,13,1), Moscow_ano3)
plt.plot(np.arange(1,13,1), Moscow_ano4)
plt.legend(['ano1','ano2','ano3','ano4'])

np.array_equal(Moscow_ano1,Moscow_ano2) # verifica se dois array's são iguais.

np.allclose(Moscow_ano1,Moscow_ano2, 0.01) # irá retornar True se a diferença entre os elementos do array for menor que o valor de 0.01 fornecido.

"""No decorrer deste curso, você pode notar uma certa similaridade dos números e arrays com os escalares, vetores e matrizes da matemática. Por isso, vamos falar um pouco sobre esses elementos.

Escalares

Os escalares são números simples utilizados na matemática ou computação. São números que utilizamos em uma soma ou multiplicação. Por exemplo, a temperatura de hoje é 27 °C, ou o meu peso é 70 kg.

Vetores

Em contraste, um vetor é uma estrutura de dados que representa múltiplas quantidades relacionadas. Por exemplo, uma sequência dos pesos dos boxeadores de uma determinada categoria. Nesse caso, um exemplo de vetor que representaria os pesos de quatro boxeadores seria esse: $(70.0,72.0,71.2,70.5)$. Outro uso comum para os vetores é a representação da posição das coordenadas de um objeto no espaço. No exemplo da figura abaixo temos o ponto A nas coordenadas (4,3). Os arrays da biblioteca Numpy são propícios para guardarmos informações deste tipo.

Figura de um ponto A, em azul, no plano cartesiano.

Matrizes

Assim, como os vetores, as matrizes são estruturas de dados que representam múltiplos valores relacionados. Uma tabela de dados pode ser representada por uma matriz. Aqui um exemplo de uma matriz com 3 linhas e 3 colunas:

Figura de uma matriz com três linhas e três colunas

Mas também podemos ter matrizes 3D, ou com mais dimensões. No exemplo abaixo você pode ver uma matriz 3D.

Figura de uma matriz com 3 dimensões, representada por 3 matrizes, dispostas uma atrás da outra e vistas sob um ângulo diagonal. Cada matriz é uma matriz 3x3 que, juntas, formam a matriz de 3 dimensões.

Matrizes 3D possuem aplicações mais avançadas como o processamento de imagens, trabalho com animações e modelagem matemática.

Um termo que você irá ouvir bastante neste curso é “dimensões”. Esse termo será utilizado aqui para dizer em quantos eixos uma informação varia. Por exemplo, um vetor é uma sequência de valores, portanto, podemos dizer que varia em apenas uma dimensão, é unidimensional. Já uma matriz 2D, uma tabela de dados, possui linhas e colunas, por isso dizemos ser bidimensional.

O termo dimensão também pode ser usado para se referir ao número de linhas e colunas presentes em uma matriz. Podemos ter uma matriz com 5 linhas e 3 colunas. Eventualmente você pode ver o número de linhas e colunas de uma matriz sendo mostrado no seu canto inferior direito. Sempre escrevemos primeiro o número de linhas e posteriormente o número de colunas. Esses números são importantes porque para operações de soma e multiplicação, por exemplo, as dimensões das matrizes precisam ser compatíveis. Só podemos somar matrizes com número de linhas e colunas iguais. Já para a multiplicação ser possível precisamos que o número de colunas da primeira matriz seja igual ao número de linhas da segunda.

### Exercício
Patty é uma cientista que está analisando uma base de dados. Ela está utilizando a biblioteca Numpy para avaliar as colunas de um array com dados de um sensor de calor. Cada coluna representa uma mesma informação coletada por um mesmo sensor em momentos diferentes. Para validar se o sensor continua calibrado, ela precisa que a diferença entre os valores nas posições de um array de nome `base` e uma coluna do array `medidas` sejam menores que 0.01.

Como ela pode utilizar a Numpy para fazer essa avaliação sobre a coluna zero do array.

`np.allclose(base, medidas[:,0],0.01)`
"""

plt.plot(datas,Kaliningrad)

Kaliningrad  # NaN, um valor não numérico, um tipo de erro que aparece qndo estamos trabalhando com matemática

"""NaN, um valor não numérico, um tipo de erro que aparece qndo estamos trabalhando com matemática.


Verificando a quantidade de valores NaN
"""

sum(np.isnan(Kaliningrad))  # verifica valores não numéricos

"""Ou:"""

np.sum(np.isnan(Kaliningrad))

"""Lidando com NaN"""

(Kaliningrad[3]+Kaliningrad[5])/2

Kaliningrad [4] = np.mean([Kaliningrad[3],Kaliningrad[5]])

"""Comparar dois arrays diferentes:"""

np.mean(Moscow)

np.mean(Kaliningrad)

"""###Exemplo:
Chegou a hora de você testar os conhecimentos desenvolvidos durante a aula. Continuando com o projeto das laranjas/toranjas agora você deve selecionar parte dos dados. As colunas que iremos avaliar são as de diâmetro e peso. Crie arrays específicos para guardar o diâmetro e peso da laranja e toranja. O diâmetro está na coluna zero e o peso na coluna 1. Os dados referentes a laranja vão até a linha 4999 e os referentes à toranja iniciam na linha 5000 do arquivo.

Após fazer a seleção de dados, importe a biblioteca matplotlib e crie um gráfico para a laranja e para a toranja do peso pelo diâmetro.
"""

diametro_laranja = dado[:5000,0]
diametro_toranja = dado[5000:,0]
peso_laranja = dado[:5000,1]
peso_toranja = dado[5000:,1]

import matplotlib.pyplot as plt

plt.plot(diametro_laranja, peso_laranja)
plt.plot(diametro_toranja, peso_toranja)

"""### 3 - Operações entre arrays"""

plt.plot(datas, Moscow)

"""Regressão Linear: y=ax+b  

Equação da reta
"""

x = datas

y = 2*x+80

plt.plot(datas, Moscow)
plt.plot(x, y)

np.power(Moscow-y, 2) # Eleva um número a uma potência (quadrado)

np.sum(np.power(Moscow-y, 2)) # Somar todos os números

np.sqrt(np.sum(np.power(Moscow-y, 2))) # Calcular a raiz

y = 0.52*x+80

plt.plot(datas, Moscow)
plt.plot(x, y)

np.sqrt(np.sum(np.power(Moscow-y, 2)))

np.linalg.norm(Moscow-y) # Calcula a norma de um vetor

Y = Moscow
X = datas
n = np.size(Moscow)

X**2

(X**2).shape

a = (n*np.sum(X*Y) - np.sum(X)*np.sum(Y))/(n*np.sum(X**2) - np.sum(X)**2)
a

b = np.mean(Y) - a*np.mean(X)
b

y = a*X+b

np.linalg.norm(Moscow-y)

"""### Exemplo:
Thaís queria desenhar um círculo com a ajuda do computador. Para desenhar a parte superior do círculo ela sabia que deveria usar a equação:

y = sqrt(1 - x ^ 2)

E para a parte inferior bastava utilizar a mesma equação multiplicada por -1.

Qual sequência de código ela deve usar para construir o gráfico corretamente usando a Numpy e sabendo que ambas as partes do círculo devem ter a mesma cor?


Para desenhar um círculo, você precisa calcular a parte de cima e a parte de baixo. A parte de cima é dada pela equação (y = \sqrt{1 - x^2}), que te dá os valores de (y) para cada (x) na parte superior do círculo. Para a parte de baixo, você simplesmente multiplica essa equação por -1, resultando em (y = -\sqrt{1 - x^2}).

Então, você gera uma sequência de valores de (x) que vão de -1 a 1. Para cada um desses valores de (x), você calcula (y) para a parte de cima e (y) para a parte de baixo. Depois, você plota ambas as partes no mesmo gráfico, usando a mesma cor para que pareçam uma única figura
"""

import numpy as np
import matplotlib.pyplot as plt

# Gerar uma sequência de valores de x de -1 a 1
x1 = np.arange(-1, 1.01, 0.0001)

# Implementação da fórmula
y1 = np.sqrt(1 - x1**2)
y2 = -np.sqrt(1 - x1**2)

# Plotar o gráfico com as duas partes do círculo
plt.plot(x1, y1, 'r')
plt.plot(x1, y2, 'r' )

# Adicionar o título do gráfico e os rótulos dos eixos x e y
plt.title("Círculo")
plt.xlabel("Eixo x1")
plt.ylabel("Eixo y")

# Exibir o gráfico
plt.show()

"""### Estimativa de valor"""

plt.plot(datas, Moscow)
plt.plot(X,y)
plt.plot(41.5,41.5*a+b,'*r')

plt.plot(datas, Moscow)
plt.plot(X,y)
plt.plot(41.5,41.5*a+b,'*r')
plt.plot(100,100*a+b,'*r')

"""### 4 - Números Aleatórios"""

np.random.randint(low=40,high=100,size=100)

np.random.uniform(low=0.10,high=0.90,size=100) # Gera números aleatórios, sempre que rodamos o código.

coef_angulares = np.random.uniform(low=0.10,high=0.90,size=100)

for i in range(100):
  print(np.linalg.norm(Moscow-(coef_angulares[i]*X+b)))

norma1 = np.array([])
for i in range(100):
    norma1 = np.append(norma1,np.linalg.norm(Moscow-(coef_angulares[i]*X+b))) # append: anexa valores ao finalde um array.

norma1

coef_angulares[1]

np.random.seed(16) # garante que os números não sejam aleatórios
np.random.uniform(low=0.10,high=0.90,size=100)

np.random.seed(84)
coef_angulares = np.random.uniform(low=0.10,high=0.90,size=100)
norma1 = np.array([])
for i in range(100):
    norma1 = np.append(norma1,np.linalg.norm(Moscow-(coef_angulares[i]*X+b)))

norma1

coef_angulares

dados1 = np.column_stack([norma1, coef_angulares])

dados1.shape

np.savetxt('dados1.csv',dados1,delimiter=',') # cria um arquivo para fazer download

"""### Exemplo:

Claro! Vamos revisar os conceitos sobre a geração de números aleatórios com NumPy.Quando você utiliza a função `np.random.uniform()`, ela gera números aleatórios dentro de um intervalo definido. No entanto, se você quiser garantir que a sequência de números gerados seja a mesma em diferentes execuções, você deve usar a função `np.random.seed()`. A semente (seed) é um número que inicializa o gerador de números aleatórios. Se você definir a mesma semente antes de gerar os números, obterá a mesma sequência de resultados. Por exemplo:
Se você executar esse código várias vezes, sempre obterá o mesmo array.Agora, se você reiniciar a semente antes de gerar novos números, como no caso do código da Márcia, ela acabará gerando a mesma sequência de números para ambas as variáveis a e b. Isso significa que a e b serão idênticos, o que não é o que ela deseja.Pense em como você poderia ajustar o código dela para gerar duas sequências diferentes. Que tal tentar mudar a semente antes de gerar a segunda sequência? Isso pode ser uma boa solução! 😊
"""

import numpy as np

np.random.seed(42)
a = np.random.uniform(0, 1, 5)
np.random.seed(42)
b = np.random.uniform(0, 1, 5)

print("Sequência 1 de a:", a)
print("Sequência 1 de b:", b)
# A sequência de código vai gerar 5 números entre 0 e 1. Além disso, o seed(42) vai fazer com que as duas sequências sejam iguais.

"""O primeiro valor dentro do `random.uniform` é o primeiro valor possível na sequência, o segundo valor é o último valor possível e o último é o número de valores na sequência. Além disso, colocar o `random.seed` com o mesmo número logo antes da chamada da função faz com que seja gerada a mesma sequência. Um exemplo de código que resolveria o problema corretamente é este, repare que serão geradas sequência de 5 números:"""

import numpy as np

np.random.seed(42)
a = np.random.uniform(0, 5, 5)
np.random.seed(8)
b = np.random.uniform(0, 5, 5)

print("Sequência 1 de a:", a)
print("Sequência 1 de b:", b)

"""### Exemplo 2:
Você começou os seus estudos com a biblioteca Numpy e resolveu utilizá-la para substituir um cálculo que estava sendo realizado com listas do Python. A lista que você tem em mãos é igual a:
"""

xx = [0,1,2,3,4,5,6,7,8,9,10]

"""Essa lista estava sendo utilizada para calcular os diversos valores de `y` na equação `y = x + 3 / 2`. Como ficaria o código em Numpy para substituir o seguinte trecho de código?"""

xx = [0,1,2,3,4,5,6,7,8,9,10]
yy = []

for i in xx:
  yy.append(i + 3 / 2)
  print(yy)
  print(xx)

print(yy)
print(xx)

import numpy as np

xx = np.array([0,1,2,3,4,5,6,7,8,9,10])  # Transformando a lista em um array NumPy
yy = xx + 3 / 2  # Operação vetorizada, sem loop

print(yy)